---
title: "型のメンタルモデル"
cssclass: zenn
date: 2024-02-10
modified: 2024-02-10
AutoNoteMover: disable
tags: type/zenn/book, TypeTheory/Subtyping, TypeScript/type, math/algebra
aliases: AST本『型のメンタルモデル』
---

## 表示的意味論

型についてのメンタルモデルについて考える上で、プログラミング言語の意味論は重要な概念です。

プログラムというのは実際にはただの有限個の記号列ですが、それに対して実行したりなんらかの意味を与えて解釈するための定義することや枠組みそのものを「**プログラム意味論**」と言います。

意味論にはいくつかの種類が存在しますが、その一つである「**表示的意味論** (denotational semantics)」では、プログラムの実効方法とは関係なく、なんらかの数学的な構造に対応させて意味を定めるようなアプローチであり、項 (変数や値、式など) の意味が数値や関数などの数学的な対象として捉えられます。この方法では、メモリや詳細な計算ステップなどについてはすべて捨象して、プログラムの抽象的な本質部分にフォーカスして考えます。

意味論には他にも「**公理的意味論** (axiomatic operation)」や「**操作的意味論** (operational semantics)」などがあり、例えば『型システム入門』の書籍では操作的意味論がメインの意味論として展開されています。

この本では TypeScript の型と部分型関係における表示的意味論を考えていきますが、実際にはそこまで専門的かつ厳密な意味論は扱いません。例えば領域理論([domain theory](https://en.wikipedia.org/wiki/Domain_theory))などの筆者自身の数学能力を超えるものに扱えませんので注意してください。厳密な意味論ではなく、あくまで型についてのメンタルモデルを構築するという名目で数学を利用します。

## 型のメンタルモデル

TypeScript における型と部分型関係についての表示的意味論を考える上で「型についてのメンタルモデル」を構築するための数学的なツール (概念) は以下の５つとなります。これらの理論に基づいて数理的な意味を与えます。

- 順序理論 ([order theory](https://en.wikipedia.org/wiki/Order_theory))
- 集合論 ([set theory](https://en.wikipedia.org/wiki/Set_theory))
- 束論 ([lattice theory](https://en.wikipedia.org/wiki/Lattice_(order)))
- 環論 ([ring theory](https://en.wikipedia.org/wiki/Ring_theory))
- 圏論 ([category theory](https://en.wikipedia.org/wiki/Category_theory))

それぞれの数学理論に基づく代数的構造は相互に関連しており、大雑把に言ってしまえば TypeScript の型の集まりは上記のような５つの別々の見方ができます。それぞれのツールを使うことで型が持つ性質や機能についてその見方に立って別々の方向から推論することができるようになります。

:::message
代数的構造というと群 (group) を始めとする演算を備えた集合の数学的構造が一般的には考えられ、その捉え方としては上記の環論に基づく「半環」が最も代数的構造らしいものに相当しますが、ここでは上記すべてについて代数的構造 (あるいはそのような見方) と呼ぶことにしています。
:::

各構造が持つ代数法則に基づいて型機能の振る舞いを予測できるので、公式ドキュメントには書いていない裏ルールとして機能するかもしれません。もちろん実装とモデルが正確に一致していないような場合もあるでしょうが、大雑把にはこのような性質を持つ概念や構造に対応すると考えることで機能についての推論 (特に型の互換性についての推論) が可能となります。言うなれば「**代数法則による人間型推論**」です。

型について別々の側面からみたときに部分的に機能する良いモデルを複数個用意して、それらを関連させることでうまくメンタルモデルを構築できるはずです。モデルを構築する上では代数法則に反した挙動については例外として捉えるようにしていきます。

## 最初から除外する型

`any` 型と列挙型は最初から考慮しないものとします。『部分型関係の概念』の章でも解説しますが、両者は様々な型の変数に対して純粋な部分型互換性ではなく割当互換性に基づく割当を行うからです。

特に列挙型は TypeScript において独自すぎる型であり、上記の事実を踏まえても考えるモデルのシンプルさを破壊するのでこの本では一切言及しないことにします。

https://typescriptbook.jp/reference/values-types-variables/enum/enum-problems-and-alternatives-to-enums

基本的には、プリミティブ型や一般的なオブジェクト型といったベーシックな型の部分型関係がなす構造を考えるので、利便性の高い型の機能などについても暗黙的に排除している場合があります。
