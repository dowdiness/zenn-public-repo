---
title: "圏論による模型"
cssclass: zenn
date: 2024-02-10
modified: 2024-02-10
AutoNoteMover: disable
tags: type/zenn/book, TypeTheory/Subtyping, TypeScript/type, math/algebra
aliases: AST本『圏論による模型』
---

## 圏論の導入

圏論 ([category theory](https://en.wikipedia.org/wiki/Category_theory)) とは「**対象** (object)」の集まりとそれらの間の関係を表す「**射** (morphism あるいは arrow)」の集まりがなす構造である「**圏** (category)」を研究する数学の分野です。

圏論の概念は特に [Haskell](https://www.haskell.org) という純粋関数型言語で利用されていますが、Haskell 以外でも圏論は使えますし、実はオブジェクト指向言語の部分型関係においても一部の概念 (変性) は圏論由来のものです。圏論においては、対象とするシステムが以下で説明する「圏の公理」さえ満たせばそれを圏としてみなせるので、TypeScript が持つような型システムについても圏を考えることができます。

:::message alert
この章で考える圏は、Haskell における「**対象を型、射を関数とする圏**」である [Hask](https://ja.wikibooks.org/wiki/Haskell/%E5%9C%8F%E8%AB%96) とは異なるものであることに注意してください
:::

## 圏とは

圏とは簡単に言えば複数のモノの集まりとそのモノ同士の関係を表す矢印からなる、ある種のシステムです。具体的な定義を与えると、考えている領域において以下のようなモノ(対象)とその間の関係を示す矢印(射)が存在するとします。

- 対象の集まり $A, B, C \ldots$ と、その対象間に射の集まり $f, g, h \ldots$ がある
- 任意の射の組 $f: A \rightarrow B,\ g: B \rightarrow C$ の合成射(composition) $f \circ g$ が存在する
- 任意の対象 $A$ に恒等射(identity arrow) $id_A: A \rightarrow A$ が存在する

このとき、任意の射 $f: A \rightarrow B,\ g: B \rightarrow C,\ h: C \rightarrow D$ について以下の「圏の公理」を満たすとき、その構造は圏(category)であると言います。

- 結合律 (associativity): $h \circ (g \circ f) = (h \circ g) \circ f$
- 単位律 (identity): $f \circ id_A = f = id_B \circ f$

あるシステムを考えるとき、そのシステムがこの圏の公理を満たしてさえいればそれは圏であると言うことができるので、様々なものが圏という構造であるとみなせます (あるいは圏を構築できます)。

圏は一般的に英名である **C**ategory の頭文字 C のスクリプトフォントを使って $\mathscr{C}$ のように表記されたり、他のアルファベットを使って $\mathscr{A, B}$ のように表記されます。このとき、圏の公理を満たす構造である圏 $\mathscr{C}$ がどのような構造が図示すると以下のような構造となります。

![圏のイメージ](/images/ast/img_category-image.png)

恒等射はある対象から自分自身への矢印であり、対象ごとに必ず存在し、対象 $A$ の恒等射は $1_A$ や $id_A$ などと表記されます。

また一般に、対象間の射の数は制限されておらず、以下のように複数個の射が存在してもよいのが圏という構造の特徴です。つまり、図のように二つの対象の間には同じ方向の射が何本あってもよいですし、逆の方向の射も何本あってもよいということになります。

![射の個数](/images/ast/img_c-arrow-number.png)

代表的な圏の構造として、ミニマルな圏をいくつか図示して考えてみます。まず、対象が一つも存在しない圏は $\mathbf{0}$ と呼ばれ、対象が一つもないので射も存在しません。この圏が最もシンプルな圏であり、**空圏** (empty category) とも呼ばれます。そして次にシンプルなのは対象が一つのみの $\mathbf{1}$ と呼ばれる圏で、この圏は一つの対象とその対象についての恒等射のみを持ちます。次に複雑となるのは $\mathbf{2}$ と呼ばれる圏で、この圏は二つの対象とそれぞれの恒等射と、異なる対象間に一つの射を持つ構造です。そして、対象が三つで、異なる対象間の射が三つとなる圏は $\mathbf{3}$ と呼ばれ、これらの圏は以下のような構造となっています。

![最小構成の圏](/images/ast/img_minimal-categories.png)

ここまで圏の図式で対象からその対象自身への射である恒等射を書いてきましたが、一般的には恒等射の表現は冗長になるため圏の図式では省略されることが多いので注意してください。

そして、以下のような対象と射の図式において始点と終点の合成の結果が等しくなるとき、つまり対象 $A$ から $C$ を経由して $D$ へ到達するパスと、対象 $A$ から $B$ を経由して $D$ へ到達するパスの結果が同じになる、言い換えれば射の合成 $h \circ g = i \circ f$ となるとき、図式が可換(commutative)であると言い、このような図式を「可換図式 ([commutative diagram](https://en.wikipedia.org/wiki/Commutative_diagram))」と呼びます。

$$
  \begin{CD}
     A @>{f}>> B \\
  @V{g}VV {\large\circlearrowleft} @V{i}VV \\
     C   @>{h}>>  D
  \end{CD}
$$

:::message alert
実際の合成射はこの図式では表現されていません。
:::

上で説明したように対象間の射は何個あってもいいので、二つの射 $h \circ g, i \circ f$ が同一となることは決して自明ではありませんが、このような可換図式が与えられたときは同一として考えて良いわけです。

## 順序集合の圏

さて、最低限の圏の知識を入れたのでここからは本題に入る前の下ごしらえとして、いくつかの追加の圏と概念を解説していきます。

ここまで何度も述べてきたように考えている構造が圏の公理を満たしさえすればその構造は圏としてみなすことができます。この本では多くの順序集合(全順序集合、半順序集合、前順序集合)を扱ってきました。順序集合を $(P, \prec)$ として、台集合 $P$ の各要素を対象(object)として、要素間の順序関係 $\prec$ を射(arrow)として扱うことで順序集合は圏としてみなせます。

つまり、要素 $a, b$ を圏の対象 $a, b$ として扱い、さらにその間の順序関係 $a \prec b$ を射 $a \rightarrow b$ として扱います。つまり以下のように射と順序関係を論理的な同値([if and only if](https://en.wikipedia.org/wiki/If_and_only_if))として扱います。

$$
a \le b \Leftrightarrow a \rightarrow b
$$

:::message
"if and only if" は片方が成り立つときに限ってもう片方が成り立つという関係を表現し、"iff" と省略されて $\Leftrightarrow$ や $\equiv$ の記号で表現されます。iff の関係では片方が成り立たないならもう片方も成り立ちません。
:::

それでは実際に順序集合が圏になることを確認していきます。これまで順序集合を表現するためにハッセ図を書いてきましたが、これ自体で圏の構造のある種の表現ができます。例えば、自然数 $\lbrace 1, 2, 3, 4, 5 \rbrace$ を台集合とする大小関係 $\le$ による鎖(全順序集合)は以下のようにハッセ図で表現可能でした。

```mermaid
graph LR
1
2
3
4
5
1 --> 2 --> 3 --> 4 --> 5
```

ハッセ図では反射律($a \prec a$)の表現はしませんでしたが、ハッセ図をやめて反射律までも表現すると図式は以下のようになります。

```mermaid
graph LR
1
2
3
4
5
1 --> 2 --> 3 --> 4 --> 5
1 --> 1
2 --> 2
3 --> 3
4 --> 4
5 --> 5
```

また、構造を圏としてみなすには圏の公理を満たす必要がありましたが、その前の前提として圏には恒等射(identity arrow)が必要でした。順序集合における射は順序関係なので、反射律による自分自身への順序関係 $a \prec a$ が恒等射 $a \rightarrow a$ に相当します。上記の図で、順序関係 $1 \le 2$ を $f: 1 \rightarrow 2$ のように置き換え、対象 $a$ についての反射律(reflexivity)による自身への順序関係 $a \le a$ を $r_a: a \rightarrow a$ とするように表現すると以下のように図示できます。

```mermaid
graph LR
1
2
3
4
5
1 -->|f:1→2| 2 -->|g:2→3| 3 -->|h:3→4| 4 -->|i:3→5| 5
1 -->|r1:1→1| 1
2 -->|r2:2→2| 2
3 -->|r3:3→3| 3
4 -->|r4:4→4| 4
5 -->|r5:5→5| 5
```

これで圏として扱える準備が整ってきましたが、圏となる構造の前提には更に任意の射の組 $f: A \rightarrow B,\ g: B \rightarrow C$ に対して合成射(composition) $f \circ g$ が存在する必要があります。

ところで、全順序集合というのはそもそもの前提として前順序集合であり、反射律に加えて推移律($a \prec b \land b \prec c \Rightarrow a \prec c$)を満たしていました。

順序集合を圏としてみなした場合、射は順序関係 $\prec$ (鎖なら $\le$) になるわけですから、二つの射 $a \prec b$ と $b \prec c$ の合成射は $a \prec c$ という順序関係となります。そして $a \prec b$ かつ $b \prec c$ なら $a \prec c$ であることは推移律によって保証されています。例えば上記の鎖であれば、$1 \le 2$ と $2 \le 3$ は射 $f: 1 \rightarrow 2$ と $g: 2 \rightarrow 3$ に相当するわけですから、反射律による関係 $1 \le 3$ は合成射 $g \circ f: 1 \rightarrow 3$ というように作ることができます。つまり、**少なくとも前順序集合であるならば順序集合には合成射が存在する**ことになります。

ここでハッセ図のことを思い出すと、ハッセ図は $x < y < z$ (等号含まない)となる $z$ が存在しない場合の $x < y$ という被覆関係($x \lessdot y$)のみを表示していました。上記の鎖でいえば $f, g, h, i$ の射による関係のみです。このような被覆関係以外のすべての順序関係、例えば合成射 $g \circ f: 1 \rightarrow 3$ なども含めてすべての順序関係による射を描ければ圏の完全な図式ができそうです。まずは、射の合成の代わりに単純にすべての順序関係を書いてみます。

![鎖の推移律によるすべての順序関係](/images/ast/img_chain-transitive-arrow.png)

$f, g, h, i$ を射の表現に直して、すべての順序関係をそれらの合成射として以下のように表現しなおしましょう。これで圏の完全な図式が完成しました。

![鎖の圏](/images/ast/img_chain-category.png)

ハッセ図では鎖の被覆関係を矢印として表現していましたが、このように被覆関係について推移律を使えば要素間のあらゆる順序関係を構成できます。つまり順序関係を表すあらゆる射(順序関係)を合成することができるわけです。

ここで再確認すると、圏の公理とは任意の射 $f: A \rightarrow B,\ g: B \rightarrow C,\ h: C \rightarrow D$ についての以下の法則でした。

- 結合律 (associativity): $h \circ (g \circ f) = (h \circ g) \circ f$
- 単位律 (identity): $f \circ id_A = f = id_B \circ f$

実際に圏の公理を満たしていることを確認してきます。

結合律についてですが、上記の鎖を使って具体的に考えると $h \circ (g \circ f)$ は射 $f: 1 \rightarrow 2$ と $g: 2 \rightarrow 3$ を先に合成してから、$h: 3 \rightarrow 4$ をその合成結果に合成しています。まずはこれらの射を順序関係と対応させて二つの射の合成までを書き下すと以下のようになります。

射 | 順序関係
--|--
$f: 1 \rightarrow 2$ | $1 \le 2$
$g: 2 \rightarrow 3$ | $2 \le 3$
$h: 3 \rightarrow 4$ | $3 \le 4$

射の合成 $g \circ f$ は $f: a \rightarrow b$ と $g: b \rightarrow c$ があったときに $f$ の始点 $a$ から終点 $b$ へと移動し、同じ対象である $g$ の始点 $b$ から $c$ へと動くパスの移動としても考えられます。つまり $a \rightarrow b \rightarrow c$ というように動きますが、最終的にはどのような中継点を通ろうが最初の始点 $a$ と最後の終点 $c$ を結ぶパスを考えるわけで、$g \circ f$ なら順番的に $f$ から考えて $g$ を後に考えます。

このような射の合成の順番を推移律を表現する論理式の順番と対応させて論理的な同値(iff)として扱うようにします。

$$
\lbrace g \circ f: (b \rightarrow c) \circ (a \rightarrow b) = a \rightarrow c \rbrace\ \text{iff}\ \lbrace a \le b \land b \le c \Rightarrow a \le c \rbrace
$$

順序関係の射の合成のやり方はこれを使って以下のように考えられます。

射 | 推移律 | 合成結果
--|--|--
$g \circ f: 1 \rightarrow 3$ | $1 \le 2 \land 2 \le 3 \Rightarrow 1 \le 3$ | $1 \le 3$
$h \circ g: 2 \rightarrow 4$ | $2 \le 3 \land 3 \le 4 \Rightarrow 2 \le 4$ | $2 \le 4$

問題となる三つの射の合成結果が同じになればいいわけですが、このように考えていくと、$h \circ (g \circ f)$ の方は反射律 $1 \le 3 \land 3 \le 4 \Rightarrow 1 \le 4$ を使って合成した結果は $1 \rightarrow 4$ となります。同様に射 $(h \circ g) \circ f$ も反射律 $1 \le 2 \land 2 \le 4 \Rightarrow 1 \le 4$ を使って合成した結果が $1 \rightarrow 4$ となり、二つの合成の結果が等しくなることが分かります。

射 | 推移律 | 合成結果
--|--|--
$h \circ (g \circ f): 1 \rightarrow 4$ | $1 \le 3 \land 3 \le 4 \Rightarrow 1 \le 4$ | $1 \le 4$
$(h \circ g) \circ f: 1 \rightarrow 4$ | $1 \le 2 \land 2 \le 4 \Rightarrow 1 \le 4$ | $1 \le 4$

射の合成の順番は論理和 $\land$ の前後の順番に対応させたわけですが、そもそも論理和という演算はそのオペランドの順番を変更しても結果は変わらないということが[代数法則である可換律](https://en.wikipedia.org/wiki/Logical_disjunction)(commutativity)によって定められています。したがって、推移律を表す論理式についてオペランドの順番をどのように書こうが同じ結果になります。

最後に単位律を考えると、単位律はある対象 $a$ についての恒等射 $id_a$ とその対象から別の対象 $b$ へ接続する射 $f: a \rightarrow b$ との合成が $f$ 自体となるということを表現しています。$id_a \circ f$ という射の合成は推移律の論理式 $a \le b \land a \le a \Rightarrow a \le b$ に相当するので合成結果は $a \le b$ を表す $f$ そのものになります。

同様に $f \circ id_a$ という射の合成は推移律の論理式 $a \le a \land a \le b \Rightarrow a \le b$ に相当するので合成結果は $a \le b$ を表す $f$ そのものになります。したがって以下が成り立ちます。

$$
id_a \circ f = f = f \circ id_a
$$

したがって、鎖(全順序集合)は圏を構築できます。以下の図は鎖の圏におけるすべての射を表現したものです。

![鎖の圏](/images/ast/img_chain-category.png)

このように全順序集合は圏の公理を満たすので圏を構築できる訳ですが、前順序集合も反射律と推移律を持つので同様に圏となります。結局のところ反射律と推移律にが圏の公理を保証するので順番集合(前順序集合、半順序集合、全順序集合)は圏としてみなすことができます。

そして、順序集合の圏の特徴的なポイントは一般的な圏に比べて射の数が少ないところです。対象間の射の数は制限されておらず二つの対象間に射がいくつあろうが良いわけですが、順序関係は二つの対象に関係があるかないかだけの二択となり、順序関係がある場合でも一方向につき一つなので、二対象 $a, b$ の間には射があったとしても高々二つしか存在しません。関係がある場合には推移律を使った合成射についても対象間でただ一つに定まり、可換となります。

より具体的に見ると、全順序集合なら $a \le b$ という関係から必ず一つの射が存在し、半順序集合なら関係が存在したとしても $a \le b$ による射が一つだけで、二要素が比較不能ならそもそも射が一つも存在しないということになります。前順序集合では双方の関係によるサイクルがある場合(同値な要素間)には $a \le b$ と $b \le a$ という二つの射がある場合がありますが、その他は全順序集合と半順序集合と同じことになります。

```mermaid
graph BT

subgraph C[前順序集合]
direction BT
i --> j & k
j --> l

k --> l
subgraph C'[同値要素]
direction LR
j --> m
m --> j
end
end

subgraph B[半順序集合]
direction BT
e --> f & g
f --> h
g --> h
end

subgraph A[全順序集合]
direction BT
a --> b --> c
end
```

順序集合の圏における異なる対象間の射の数をまとめると以下のようになります。

順序集合 | 射の数
--|--
前順序集合 | 高々２個 (0, 1, 2 の場合がある)
半順序集合 | 高々１個 (0, 1 の場合がある)
全順序集合 | 必ず１個

## 同型性

順序理論の章において、要素同士が同一(identical)であることとは別に双方向に関係があるというう緩い同じさを表す同値関係(equivalence relation)を導入しましたが、どの程度の違いを許容して要素同士の同じさを語るかは非常に重要なトピックであり、考える構造の抽象度などによって変わってきます。

特に圏論は抽象化を何度も繰り返すような分野であり、圏における対象同士の同じさは同一性よりも緩いく、圏における対象同士の同じさは同型性(isomorphism)という概念によって表されます。例えば以下の図のように対象 $A, B$ とその間の射 $f: A \rightarrow B$, $g: B \rightarrow A$ があったとします。

```mermaid
graph LR
A --->|f: A → B| B
B --->|g: B → A| A
A -->|id_A| A
B -->|id_B| B
```

このとき、以下が成り立つなら射 $f$ は「**同型射** (isomorphism)」であると言います。また、同型射が存在する対象 $A, B$ は**同型** (isomorphic) であると言い、$A \cong B$ と表記します。

$$
g \circ f = id_A \land f \circ g = 1_B
$$

なお同型射である射 $g$ は射 $f$ の逆射と呼ばれ $g = f^{-1}$ とも表記されます。

同型性とは圏の構造における対象の同じさを語る概念です。対象と射の種類によってそれが具体的にどのような同じさなのかは変わってきますが、対象と射からなる圏という構造においては同型射が存在する場合にその対象同士を同じものであるとみなすことができます。例として前順序集合において同値関係を入れましたが、前同値集合の圏では対象同士の同値($\equiv$)と同型($\cong$)が一致し、構造上では本質的に同じものであると扱えます。実際、順序関係の反射律と推移律による関係の合成射が唯一に定まることから双方向に関係がある(同値な)要素同士ではその要素同士が同型であることが言えます。

このような双方向に関係を持つ要素は同じものとして同値類にまとめることができ、これによって半順序集合に変換できました。

```mermaid
graph LR

subgraph C[前順序集合]
  direction BT
  i[e]
  j[f]
  k[g]
  l[h]
  m

  i --> j & k
  j --> l

  k --> l
  subgraph C'[同値要素]
    direction LR
    j -->|同型射| m
    m -->|同型射| j
  end
end

subgraph B[半順序集合]
  direction BT
  f["f (≅ m)"]
  e --> f & g
  f --> h
  g --> h
end

C -->|同型射を無くす| B
```

同型射の観点から考えれば、同型射となるような双方向の関係はサイクルとなるので、このような同型射を無くすことで対象間の射を一方向のみに整える事ができるわけです。

## 双対性と特殊な対象

### 圏論における双対性

少し話を変えますが、束論の章において双対性(duality)という概念がでてきました。圏論においても双対性の概念は重要な位置を占めます。

束論での双対は順序関係 $\le$ において一方向についての定義や証明を逆方向についても言うことができるというようなものでしたが、圏論においても射の方向を逆転することで双対概念を考えることができ、以下で説明するように特殊な対象である始対象と終対象は双対の概念となっています。

### 始対象と終対象

圏の対象にはいくつか特殊な種類のものがあります。その一つが「**始対象** (initial object)」であり、始対象とは圏内の任意の対象 $X$ に対してにただ一つの射 $I \rightarrow X$ を持つような対象 $I$ のことです。そして、始対象の双対概念となるものが「**終対象** (terminal object)」です。終対象は、始対象とは逆に圏内の任意の対象 $X$ に対してただ一つの射 $X \rightarrow T$ を持つような対象 $T$ を表します。

![始対象と終対象](/images/ast/img_initial-terminal-objects.png)

上図の圏 $\mathscr{M}$ において、$I$ が始対象であり、他の全ての対象 $T, V$ への唯一の射がそれぞれあります。逆に $T$ が終対象であり、他の全ての対象 $I, V$ からの唯一の射がそれぞれあります。イメージとしては上図の左側にあるようなすべての矢印がでていくような対象が始対象であり、逆にすべての矢印が入ってくるような対象が終対象となります。

始対象と終対象は圏において必ず存在するわけではないので、圏によってあったりなかったりします。存在する場合にはそれぞれ同型な対象をのぞいて一意に定まります。つまり、構造的には同じである同型な対象は圏においてはある種同じものとして扱えるので始対象や終対象はそのような同じもの(同型な対象)があったとしても本質的な意味では一つのものとして定まるということです。

### 順序集合での対応

順序集合の台集合とその順序関係によって構築された圏において、順序集合に最小元 $\bot$ が存在する場合には、推移律を利用して最小元となる対象から他のあらゆる対象 $X$ に向けてたった一つの射($\bot \le X$)を作ることができるので、最小元が始対象となります。

最小元の双対である最大元も同様に考えることができ、推移律を利用してあらゆる対象 $X$ から最大元 $\top$ に向けてたった一つの射($X \le \top$)を作ることができるので、最大元が終対象になります。なお下図の色付きの要素が最小元と最大元で、破線は推移律を使った関係です。

```mermaid
graph BT

subgraph C[前順序集合]
  direction BT
  l:::lub
  i:::glb

  i --> j & k
  j --> l

  subgraph C'[同値要素]
    direction LR
    j --> m
    m --> j
  end

  m -.-> l
  i -.-> m
  i -.-> l
  k --> l
end

subgraph B[半順序集合]
  direction BT
  h:::lub
  e:::glb
  e --> f
  e --> g
  f --> h
  e -.-> h
  g --> h
end

subgraph A[全順序集合]
  direction BT
  c:::lub
  a:::glb
  a --> b --> c
  a -.-> c
end

classDef lub fill:#f29
classDef glb fill:#78d
```

## 関手とは

圏内の対象とその対象間の関係である射の集まりを俯瞰的に考えるのが圏論の基本ですが、圏論という分野は抽象化を繰り返すことがよくあるため、圏(category)そのものを対象(object)として考えて、圏と圏の間で射(arrow)を考えるということを行うことができます。つまり「圏の圏」というものを考えることができるわけですが、このとき圏同士の間にある射を「関手 ([functor](https://en.wikipedia.org/wiki/Functor))」と呼びます。

### 共変関手

例えば、以下のように二つの圏 $\mathscr{C, D}$ において圏 $\mathscr{C}$ から圏 $\mathscr{D}$ への射があるとき、それを関手 $F$ と呼ぶようにします。

![関手の説明](/images/ast/img_functor-ex1.png)

関手とは、より具体的に言えば圏内の対象と射を別の圏の対象と射にそれぞれ対応づける、あるいは圏を別の圏に変換するようなものであると捉えることができます。

具体的に関手 $F$ がやることを見ていくと、まず圏 $\mathscr{C}$ のすべての対象 $A, B, C$ を圏 $\mathscr{D}$ の対象へとマッピングします。このとき関手 $F$ による対象 $A$ のマッピング先の対象は $F(A)$ のように表せます。

![関手における対象のマップ](/images/ast/img_functor-ex2.png)

対象がマッピングできたら、次に圏 $\mathscr{C}$ から圏 $\mathscr{D}$ への射のマッピングを行います。このとき関手 $F$ による射 $f$ のマッピング先の射は $F(f)$ のように表せます。

![関手における射のマップ](/images/ast/img_functor-ex3.png)

この図の例では二つの圏 $\mathscr{C, D}$ において対象と射がそれぞれ一対一に対応していますが、一般的に関手による対応付けがこのように一対一になるとは限りません。

例えば、三つの対象 $A, B, C$ から構成される同じ圏 $\mathscr{C}$ に対して $\mathscr{D}$ ではない別の圏として二つの対象から構成される $\mathscr{E}$ という圏への関手 $G$ を考えます。関手 $F$ では一対一に対象をマッピングできましたが、この関手 $G$ では圏 $\mathscr{C}$ の対象 $B, C$ を同じ対象 $G(B) = G(C)$ へとマッピングします。

![一対一の対応ではない関手](/images/ast/img_functor-ex4.png)

射 $g: B \rightarrow C$ は対象 $G(B) = G(C)$ から同じ対象への射として関手 $G$ によって射 $G(g)$ 変換されますが、この際に $G(g)$ は恒等射である必要はありません。ただし、圏 $\mathscr{C}$ の対象 $B, C$ の恒等射である $id_B, id_C$ は圏 $\mathscr{E}$ の対象 $G(B) = G(C)$ の恒等射 $G(id_B) = G(id_C)$ にマッピングされます。

これが通常の関手の性質であり、一般に圏 $\mathscr{C}$ から圏 $\mathscr{D}$ への関手 $F$ は、圏 $\mathscr{C}$ 内の任意の対象 $A, B, C$ と、射 $f: A \rightarrow B,\ g: B \rightarrow C$ について以下の公理に従います。

- $F(id_A) = id_{F(A)}$
- $F(g \circ f) = F(g) \circ F(f)$

ここまで説明してきた関手 $F$ と $G$ はこの公理に従っていますが、図をみてもらえばわかるように圏 $\mathscr{C}$ から関手を使って変換した構造 $\mathscr{D, E}$ は元々の圏 $\mathscr{C}$ 内の射の方向が保持されている事がわかります。例えば、$F(f)$ や $G(f)$ などの射は元の射である $f$ と全く同じ方向を向いています。より詳しく言えば、$F(f)$ は射 $f$ の始点である対象 $A$ と終点である $B$ を関手 $F$ により変換した $F(A)$ と $F(B)$ をそれぞれ始点、終点として同じ方向に射がでていることが分かります。言い換えれば対象間における構造(射の方向)が保持されていますね。

このような性質を持つ関手が一般的な関手となりますが、そうでない関手と区別するために通常の関手には特別な名前がついています。このような通常の関手は「**共変関手** (covariant functor)」と呼ばれます。

### 反変関手

始対象と終対象が射の方向を逆転させた双対概念であるとのべましたが、他の双対概念として圏 $\mathscr{C}$ と同じ対象 $A, B, C$ を持ち、射の方向を逆転させた圏を「双対圏(dual category)」や「反対圏(opposite category)」と呼び、$\mathscr{C}^{op}$ のように圏を表記します。双対圏 $\mathscr{C}^{op}$ を図示すると元の圏の射がすべて逆向きになっていることが分かります。

![双対圏](/images/ast/img_dual-category.png)

双対圏と元の圏の同じ対象について異なる圏の対象であることを強調するために対象 $A$ をオーバーラインを付けて $\overline{A}$ のように表記することがあります。また、方向が逆転した射についても元の射 $f: A \rightarrow B$ だとしたら双対圏の射は $\overline{f}: \overline{B} \rightarrow \overline{A}$ のように表記します。

このとき、圏 $\mathscr{C}$ から双対圏 $\mathscr{C}^{op}$ に対象と射をマッピングする $H$ のような関手があったとして、そのような関手は射の方向を逆転させているわけです。このような射の方向を逆転させる関手を「**反変関手** (contravariant functor)」と呼びます。

反変関手は共変関手と逆向きの公理に従います。一般に圏 $\mathscr{C}$ から圏 $\mathscr{D}$ への反変関手 $H$ は、圏 $\mathscr{C}$ 内の任意の対象 $A, B, C$ と、射 $f: A \rightarrow B,\ g: B \rightarrow C$ について以下の公理に従います。

- $H(id_A) = id_{H(A)}$
- $H(g \circ f) = H(f) \circ H(g)$

双対圏への反変関手で考えてみると、恒等射はそのまま写しますが、合成射については $H(g \circ f) = H(f) \circ H(g) = \overline{f} \circ \overline{g}$ と実際に上の公理に従ってることが分かります。

### 自己関手

圏の圏における対象間の射は関手だったので、圏の圏における対象の恒等射というものも考えることができます。圏を対象とする圏において恒等射はもちろんある種の関手であり、そのような関手は「恒等関手(identity functor)」と呼ばれます。

![恒等関手](/images/ast/img_identiy-functor.png)

恒等関手は圏という対象についての恒等射なのでなにも特別なことしない射として、ただ自分自身にマッピングする関手です。つまり、圏 $\mathscr{C}$ の対象 $A, B, C$ をそのまま同じ圏 $\mathscr{C}$ の対象 $A, B, C$ にマッピングし、射についても同様にすべて同じ射にマッピングします。

恒等関手のような圏から同じ圏への関手を「**自己関手**(endofunctor)」と呼びます。対象から同一対象への射は恒等射だけでなかったように、自己関手も恒等関手だけでなく様々な関手がありえます。例えば、以下の図式のように対象 $A, B$ はそのまま同じ対象に写すが、対象 $C$ は別の対象 $B$ に写し、射もそれに従うように $A, B$ に関わる射にだけ写すような自己関手 $J$ を考えることができます。この自己関手 $J$ は射の向きをそのままに構造を保存しているので共変関手でもあります。

![自己関手](/images/ast/img_endofuctor.png)

このように自己関手は恒等関手以外にもいくらでも考えることができます。

### 部分圏

そして、上記の自己関手 $J$ で圏 $\mathscr{C}$ からすべての対象と射を圏 $\mathscr{C}$ の対象 $C$ が関わるもの以外の対象と射へとマッピングを行いました。集合に部分集合(subset)があるように、圏にその部分となる副次的な構造があります。そのような構造を「部分圏([subcategory](https://en.wikipedia.org/wiki/Subcategory))」と呼びます。したがって、以下の図では、自己関手 $J$ で圏 $\mathscr{C}$ の部分圏 $\mathscr{S}$ へとマッピングをおこなっているとみなすことができます。

![部分圏](/images/ast/img_subcategory.png)

## 型と部分型関係の圏

この章の冒頭で述べたように、TypeScript の型システムで考える圏は Haskell における「**対象を型、射を関数とする圏**」である [Hask](https://ja.wikibooks.org/wiki/Haskell/%E5%9C%8F%E8%AB%96) のような圏とはまったく異なります。

むしろ Hask のような圏よりもかなりシンプルで扱いやすい構造として「**対象を型、射を部分型関係とする圏**」を考えます。部分型関係は少なくとも前順序であり、同値類の導入で半順序に変換できました。したがって型と部分型関係の圏は半順序集合の圏として構築することが可能です。

同値関係($\equiv$)を核とした商集合 $\text{TYPES'}$ を台集合として、半順序関係となる部分型関係 $<:$ を射とした圏を構築します。順序集合の圏についての説明で見たように、順序集合では反射律による関係が恒等射となります。つまり、任意の型 $T$ についての自己言及的な部分型関係 $T <: T$ が恒等射です。また、射の合成についても同様に部分型関係が満たす推移律を使って行うことで合成射を定義できます。このように構成される圏を「**部分型関係の圏**」と呼ぶことにし、圏そのものの名前を $\mathscr{Types}$ とします。この圏 $\mathscr{Types}$ を抽象化して見ると以下のような構造を持っており、このような構造の繰り返しによって構成されます。

![部分型関係の圏](/images/ast/img_subtype-category.png)

基本的に圏において二対象間の射は一つであるとは限りませんが、半順序集合の圏では対象と対象の間の射はあってもただ一つとなりますした。もちろん前順序では要素間が比較不能である場合(関係がない場合)もあるので、そのような二対象間では射が無い(部分型関係がない)わけです。推移律によって合成された部分型関係はどのルートを取ろうが一つの関係 $\le$ があるかないかだけなので、半順序集合の圏においては複数個ありえる射の合成は必ず一つの射に定まります。

もう少し具体的に見ると、例えば簡略化された以下の型の配置図ではそれぞれの線分は部分型関係を表しており、これもある種の圏の図式としてみなせます。各部分型関係はそれぞれが型(対象)から型(対象)への射となります。

```mermaid
graph BT
U["unknown"]
N["never"]
E["{ }"]
NU["null"]
UN["undefined"]
N --> NU & UN --> U
N --> E --> U
```

ただし、この図式では恒等射や合成射が表現されていませんね。推移律による合成射や型や反射律による恒等射までを表現すると以下のようになります。

```mermaid
graph BT
U["unknown"]
N["never"]
E["{ }"]
NU["null"]
UN["undefined"]
N --> NU --> U
N -.-> U
N --> UN --> U
N --> E --> U
N --> N
NU --> NU
UN --> UN
E --> E
U --> U
```

`never` 型という対象から `unknown` 型という対象までパスの基本ルートは `null`、`undefined`、`{}` の三つがありますが、どの部分型関係の推移律で射の合成を行おうが、合成結果はすべて $\text{never} <: \text{unknown}$ となります。つまり合成の方法によらず必ず一つの射に定まります。反射律による循環の関係を途中で使っても同様です。

これは始対象と終対象の観点からも言うことができます。順序集合の台集合とその順序関係によって構成された圏では、最小元と最大元がある場合にはそれぞれが始対象と終対象になりました。部分型関係の圏において、最小元と最大元は `never` と `unknown` であり、それぞれ反射律をつかってあらゆる型と唯一の射である部分型関係を作ることができます。

なお、上図で示したような恒等射と合成射は表現するとキリがないため今後も省略します。そして以下の基本型配置図は基本的な型の被覆関係を示したものですが、これも恒等射や合成射が省略された圏の図式としてみなすことができます。

```mermaid
graph BT
  U[unknown]
  N[never]
  V[void]
  O["{ }\n Object"]
  udt["User Defined Types"]
  cons["Constructor Function Types"]
  N --> undefined --> V --> U
  N --> null --> U
  Number & String & Boolean & BigInt & Symbol --> O --> U
  subgraph Wrap[Object wrapper type]
    Number
    String
    Boolean
    BigInt
    Symbol
  end
  subgraph Primitive
    subgraph Unit[Unit type]
      undefined
      null
      nl[number literal]
      sl[string literal]
      bl[boolean literal]
      bil[bigint literal]
      us[unique symbol]
    end
    subgraph Col[Collective type]
      number
      string
      boolean
      bigint
      symbol
    end
      nl[number literal] --> number --> Number
      sl[string literal] --> string --> String
      bl[boolean literal] --> boolean --> Boolean
      bil[bigint literal] --> bigint --> BigInt
      us[unique symbol] --> symbol --> Symbol
  end
  N --> nl & sl & bl & bil & us
  N --> cons --> Function --> O
  N --> udt --> O
  N --> Tuple --> Array & RT[readonly Tuple] --> ReadonlyArray --> O
```

## 型構築子の変性と関手

さて、ここまでの説明によって変性の概念を理解できる準備が整いました。これまで説明してきた圏論の概念を導入することでやっかいな型の変性(variance)の概念をイメージで理解できるようになります。

変性は圏論由来の概念であり、具体的には変性の種類である共変性(covariance)や反変性(contravariance)は圏の共変関手(covariant functor)と反変関手(contravariant functor)から来ています。

関手とは、圏から別の圏への対応付け(mapping)であり、ある圏内の対象と射をそれぞれ別の圏内の対象と射へと写すというものしたが、このとき、圏の構造(恒等射と射の合成や向き)をそのまま保ったまま別の圏へつ写す関手は共変関手と呼ばれ、逆に、射の方向(合成)を逆転させるような関手は反変関手と呼ばれていました。

さて、型と部分型関係の圏において、自己関手に相当するものはどのようなものが考えられるでしょうか？勘の良い人は変性の概念からなんとなく気づくかもしれませんが、**型構築子が自己関手に相当します**。型構築子(type constructor)とは、型から新しい型を構築するものであり、ユニオン型を構築する `|` インターセクション型を構築する `&` などであり、更に関数型を構築する `=>` や、ジェネリクス型 `Promise<T>` や `Identical<T>` なども相当します。

例えば、単一要素のタプル型 `[T]` の構築子を考えてみましょう。例えばこの構築子は圏内の対象である任意の型 `A` を引数にとって、新しい型 `[A]` を構成します。このとき新しい型 `[A]` は同じ「型と部分型関係の圏」の対象であることは明らかですね。つまり圏内の対象を別の対象にマッピングしています。

具体的には、部分型関係の圏 $\mathscr{Types}$ の部分圏として、部分集合 $N = \lbrace \text{never, null, unknown} \rbrace$ と部分型関係 $<:$ から構成される圏 $\mathscr{N}$ を考えます。型構築子 `[T]` は部分圏 $\mathscr{N}$ を以下のように別の部分圏 $\mathscr{N}\text{-tuple}$ へと写します。

![タプル型の型構築](/images/ast/img_tupel-functor-N.png)

関手は対象だけでなく射もマッピングする必要がありますが、考えている圏における射は部分型関係でした。Hask のような型と関数の圏では射のマッピングなどは自分で定義したりする必要がありますが、部分型関係は部分型付け規則によって定められているので型構築子によって射(部分型関係)の対応が自動的に決まります。

タプル型の型構築子による共変関手は、部分圏関係の圏についての抽象構造に適用して見れば以下のような構造のマッピングを行います。

```mermaid
graph LR

subgraph P["部分圏 P"]
  direction BT
  T["Join"]
  B["Meet"]
  L["A"]
  R["B"]

  B --> L --> T
  B -.-> T
  B --> R --> T
end

subgraph P'["部分圏 P-tuple"]
  direction BT
  T2["[Join]"]
  B2["[Meet]"]
  L2["[A]"]
  R2["[B]"]

  B2 --> L2 --> T2
  B2 -.-> T2
  B2 --> R2 --> T2
end

P -->|"共変関手 [T]"| P'
```

タプル型の構築子は以下のような部分型付け規則を持っているので、二つの型間の部分型関係(つまり対象間の射)は関係を保って写されます。なお、集合論や順序理論の文脈ではこのような写像を「構造を保つ写像 (order-preserving map)」と呼びます。

$$
{S <: T}
\over
{[S]<:[T]}
$$

:::message
上記のようなものは推論規則と呼ばれ、線上に列挙した前提が成立するなら下の結論を導出できる」ということを表現しています。上記の推論規則なら、二つの型 $S, T$ について部分型関係 $S <: T$ が前提として成り立つなら、そのタプル型 $[S],[T]$ についての部分型関係 $[S]<:[T]$ が成り立つということを表現しています。
:::

対象間の射である部分型関係の方向が部分型付け規則の上下で同じ方向を向いていることが分かります。つまり変換前の型同士の部分型関係と型構築子 `[T]` によって変換された型同士の部分型関係が同じであり、射の方向および構造が関手によって保持されています。したがって型構築子 `[T]` は共変関手です。この事実は上の図式で射の方向が保持されているのを見てもわかりますが、実際にコード上でも確認できます。

```ts
type R1 = Relation<[never], [null]>;
// => Subtype: [never] <: [null]
type R2 = Relation<[null], [unknown]>;
// => Subtype: [null] <: [unknown]

// また、推移律より [never] <: [unknown]
```

他にも数値リテラル型である `1` とその集合的なプリミティブ型 `number` についての部分型関係は `1 <: number` ですが、この二つの型をタプル型の構築子で写して新しい型を構成した場合にの部分型関係は保持されて `[1] <: [number]` となります。

```ts
type Unit = 1;
type Primitive = number;
type C1 = Compat<[Unit], [Primitive]>;
// => Subtype ([Unit] <: [Primitive])
```

さて、部分型関係は考えている圏での射だったわけで、このように射(関係性)の方向を保持する関手は共変関手と呼ばれていました。これがまさに変性の概念であり、型を型構築子によって写して新しい型を構成したときに部分型関係が保持される場合のときに共変(covariant)であると言い、部分型関係が逆転される場合のときに反変(contravariant)と言います。

タプル型に限らずそれぞれの型構築子は独自に変性を持ちます。変性は部分型付け規則によって支配されていますが、多くの場合には共変性を持っています。例えば `Promise<T>` 型構築子も共変であり、以下のような部分型付け規則を持っていると推論されます。

$$
{S <: T}
\over
{Promise \langle S \rangle <: Promise \langle T \rangle}
$$

実際に確かめてみると共変であることが分かります。

```ts
type C2 = Compat<Promise<string>, Promise<string | number>>;
// => Subtype: Promise<string> <: Promise<string | number>
```

集合論の章で数値リテラル型がなす冪集合のオブジェクト型への写像を考えました。これも `O<T> = { x: T }` のような型構築子による圏のマッピングであり、オブジェクト型はシンプルに言えば以下のような部分型付け規則があります。

$$
\frac{
  S_i <: T_i\ (\forall i \in 1...n)
}{
  \lbrace l_i: S_i^{\ \ i \in 1...n} \rbrace <: \lbrace l_i: T_i^{\ \ i \in 1...n} \rbrace
}
$$

これは、深さ部分型付け規則と呼ばれる部分型付け規則で、二つのオブジェクト型について対応するプロパティ(フィールド)の型がすべて部分型関係にあるなら、その二つのオブジェクト型は部分型関係にあるということを示しています。

実際のオブジェクト型の部分型付け規則はもっと複雑なルールがありますが、今の説明ではこれで十分であり、型構築子 `{ x: T }` はプロパティも一つなので、つまり上記部分型付け規則で $i = 1$ のときのみを考えれば単に二つのオブジェクト型の `x` というプロパティの型のみを比較してそれらが部分型関係なら向きを保って別の圏に写す共変関手になります。

```mermaid
graph LR
subgraph A["部分圏 N123"]
  direction BT
  B_123["never"]
  1["1"]
  2["2"]
  3["3"]
  12["1 | 2"]
  31["3 | 1"]
  23["2 | 3"]
  T_123["1 | 2 | 3"]
  B_123 --> 1 & 2 & 3
  1 --> 12
  2 --> 12
  3 --> 31
  2 --> 23
  1 --> 31
  3 --> 23
  12 & 23 & 31 --> T_123
end

subgraph A'["部分圏 N123_O"]
  direction BT
  B["{ x: never }"]
  X["{ x: 1 }"]
  Y["{ x: 2 }"]
  Z["{ x: 3 }"]
  XY["{ x: 1|2 }"]
  ZX["{ x: 3|1 }"]
  YZ["{ x: 2|3 }"]
  T["{ x: 1|2|3 }"]
  B --> X & Y & Z
  X --> XY
  Y --> XY
  Z --> ZX
  Y --> YZ
  X --> ZX
  Z --> YZ
  XY & YZ & ZX --> T
end

A -->|"共変関手 {x: T}"| A'
```

型構築子は実際には自己関手ですから、自身の構造を自身に写すということを行います。つまり、圏内のすべての型をその圏そのものに写しています。とはいえそのように全体を考えると非常にイメージがし辛い話になってしまうので、部分圏に制限して話を進めていました。

関手によって写された部分的な構造(部分圏)は実際には全体の構造 $\mathscr{Types}$ に埋め込まれており、例えばタプル型の型構築子による関手でのマッピングは構造全体で見れば以下のようになります。なお、分かりやすくするために色々な要素を省いています。

```mermaid
graph BT
subgraph A["部分圏 N"]
  direction BT
  ne1[never]
  nu1[null]
  un1[unknown]

  ne1 --> nu1 --> un1
end

subgraph A'["部分圏 N-tuple"]
  direction BT
  ne2["[never]"]
  nu2["[null]"]
  un2["[unknown]"]

  ne2 --> nu2 --> un2
end

obj["{ }"]
ne1 --> ne2
un2 --> obj --> un1
```

同様に、数値リテラル型の冪についての共変関手 `{x: T}` によるマッピングも圏全体でみれば以下のように写された部分圏がオブジェクト型の元に埋め込まれている形になります。

```mermaid
graph BT
Top[unknown]
obj["{ }"]

subgraph A["部分圏 N123"]
  direction BT
  Bot["never"]
  1["1"]
  2["2"]
  3["3"]
  12["1 | 2"]
  31["3 | 1"]
  23["2 | 3"]
  T_123["1 | 2 | 3"]
  Bot --> 1 & 2 & 3
  1 --> 12
  2 --> 12
  3 --> 31
  2 --> 23
  1 --> 31
  3 --> 23
  12 & 23 & 31 --> T_123
end

subgraph A'["部分圏 N123_O"]
  direction BT
  B["{ x: never }"]
  X["{ x: 1 }"]
  Y["{ x: 2 }"]
  Z["{ x: 3 }"]
  XY["{ x: 1|2 }"]
  ZX["{ x: 3|1 }"]
  YZ["{ x: 2|3 }"]
  T["{ x: 1|2|3 }"]
  B --> X & Y & Z
  X --> XY
  Y --> XY
  Z --> ZX
  Y --> YZ
  X --> ZX
  Z --> YZ
  XY & YZ & ZX --> T
end

Bot --> B
T --> obj --> Top
T_123 --> number --> obj

A --->|"共変関手 {x: T}"| A'
```

そして関手によって写された部分圏は更に同じ関手でまた別の部分圏として構造全体に埋め込まれます。

```mermaid
graph BT
subgraph A["部分圏 N"]
  direction BT
  ne1[never]
  nu1[null]
  un1[unknown]

  ne1 --> nu1 --> un1
end

subgraph A'["部分圏 N-tuple1"]
  direction BT
  ne2["[never]"]
  nu2["[null]"]
  un2["[unknown]"]

  ne2 --> nu2 --> un2
end

subgraph A''["部分圏 N-tuple2"]
  direction BT
  ne3["[[never]]"]
  nu3["[[null]]"]
  un3["[[unknown]]"]

  ne3 --> nu3 --> un3
end

obj["{ }"]
ne1 --> ne2
un2 --> obj --> un1
ne1 --> ne3
un3 --> obj

A -->|"共変関手 [T]"| A' -->|"共変関手 [T]"| A''
```

このように型構築子という自己関手は部分的な構造を全体に繰り返し埋め込んでいきます。

## 関数型と双関手

各型構築子は独自に変性を持っていますが、TypeScript のポピュラーな型構築子はほとんど共変になります。

反変関手となるものとしては関数型の構築子 `=>` があります。なお、これまで見てきた型構築子は型引数が一つのものでしたが、関数型では引数と返り値の型の二つが必要となります。分かりやすくジェネリクスを使って定義すると以下のようになります。

```ts
type F<Fst, Snd> = (param: Fst) => Snd;
```

実際の関数は引数の数([arity](https://en.wikipedia.org/wiki/Arity))までも考慮する必要がありますが、とりあえずここでは省略します。このように二つの型パラメータを持つ関手は双関手(bifunctor)と呼ばれます。

二つの関数型(矢印型) $S_1, S_2$ があったとして、それらの引数(parameter)の型を $P_1, P_2$ とし、返り値(return value)の型を $R_1, R_2$ とします。この二つの関数型 $S_1: P_1 \rightarrow R_1$ と $S_2: P_2 \rightarrow R_2$ の部分型付け規則は一般に以下のようになっています。

$$
{P_1 :> P_2 \quad R_1 <: R_2}
\over
{S_1: P_1 \rightarrow R_1 <: S_2: P_2 \rightarrow R_2}
$$

:::message alert
TypeScript の関数型の定義は `(x: P) => R` のようにパラメータが必要ですが、一般に関数型(function type)は矢印型(arrow type)とも呼ばれ $P \rightarrow R$ のように型として表現されることがあります。ここでは型を抽象化して書きたいのでそれに習ってパラメータを省略して書くようにしています。
:::

よく観察すると、射(部分型関係)の向きが、返り値の型については型付け規則の上下で一致しているに対して、引数の型については逆転していることが分かります。

双関手をそのまま考えると面倒なので、話をシンプルにするために二つの型パラメータのいずれかを固定して通常の関手として考えます。まず、引数の型について二つの関数型で同じ型を使うものとしてて、さらに型パラメータではなく具体的な型を $A$ として固定化した関数型 $S_{R1}: A \rightarrow R_1$ と $S_{R2}: A \rightarrow R_2$ について考えます。これらの型は型構築子 `SR<R> = (p: A) => R` という関手によって $R_1, R_2$ の型対象の間の射がどのようにマッピングされるかを考えればいいです。

となると、上記の部分型付け規則は $P_1 :> P_2$ が $A :> A$ となり、これは反射律から成り立つため無視でき、それぞれの型を $A$ に置き換えて書き直すと以下のようになります。

$$
{R_1 <: R_2}
\over
{S_{R1}: A \rightarrow R_1 <: S_{R2}: A \rightarrow R_2}
$$

これはタプル型構築子 `[T]` と同じで関手たる型構築子により元の部分型関係が変換後で保存されるため、共変関手となります。

![返り値の型](/images/ast/img_function-return-value.png)

同様に、返り値の型を共通の具体的な型 $B$ で固定した関数型 $S_{P1}: P_1 \rightarrow B$ と $S_{P2}: P_2 \rightarrow B$ を考えれば、これらの型は型構築子 `SP<P> = (p: P) => B` という関手によって $P_1, P_2$ の型対象の間の射がどのようにマッピングされるかを考えればよいわけです。同様に部分型付け規則については $R_1 <: R_2$ が $B <: B$ となり、これは反射律から成り立つため無視でき、それぞれの型を $B$ に置き換えて書き直すと以下のようになります。

$$
{P_1 :> P_2}
\over
{S_{P1}: P_1 \rightarrow B <: S_{P2}: P_2 \rightarrow B}
$$

タプル型構築子とは異なり、関手たる型構築子 `SP<P>` による変換によって、変換前の部分型関係が変換後で逆転していることが分かります。したがって、射の方向を逆転させる反変関手であることが分かります。

![引数の型](/images/ast/img_function-parameter-value.png)

関数型はこのように返り値については共変関手となり、引数については反変関手となります。

### 関数型の安全な置き換え

関数型の部分型付け規則がこのようになっている理由そのものについてはそもそも二つの関数型をどのように安全に置換可能にするかということを考える必要があります。部分型関係というのは、そもそもある型 $S$ の項が別の型 $T$ の項が期待されている文脈で安全に使用可能であるということを定める関係性のことでした。再び二つの関数型 $S_1: P_1 \rightarrow R_1$ と $S_2: P_2 \rightarrow R_2$ の部分型付け規則を眺めてみましょう。なお、分かりやすくするため関数型の名前は省略しています。

$$
{P_1 :> P_2 \quad R_1 <: R_2}
\over
{P_1 \rightarrow R_1 <: P_2 \rightarrow R_2}
$$

この部分型付け規則は、関数型 $S_1: P_1 \rightarrow R_1$ と $S_2: P_2 \rightarrow R_2$ があったときに入力値の型についての部分型関係が $P_1 :> P_2$ ($P_2$ が $P_1$ の部分型) であり、かつ出力値の型についての部分型関係が $R_1 <: R_2$ ($R_1$ が $R_2$ の部分型) になっているとき関数型 $S_2: P_2 \rightarrow R_2$ が期待される場所で $S_1: P_1 \rightarrow R_1$ で安全に置換できるといい、このとき $S_1: P_1 \rightarrow R_1$ は $S_2: P_2 \rightarrow R_2$ の部分型である、ということになります。このような型同士の関係を集合論的に図示すると下図の左側のようになります。

![関数型の入力と出力の包含関係](/images/ast/img_function-subtype-relation.jpg)

図の右側では、部分型関係の向きに注目して、共変(covariant)か反変(contravariant)を考えており、部分型関係の向きが同じなら共変で、反対なら反変となることが分かります。

構文志向の部分型システムにおいては、関数型の部分型関係は直感的に集合の包含関係として解釈できませんが、集合論的な考えをもったまま関数について以下の図の(2)のように入口と出口があるパイプの管を置き換えるようなイメージで考えると理解できます。パイプの入口と出口はそれぞれ集合を表現する領域の大きさを持つとして考えてください。

ある関数型を別の関数型で安全に置き換えるという作業は、直感的には以下の図の(2)のように入口と出口があるパイプの管を置き換えるようなイメージで考えると理解できます。パイプの入口と出口はそれぞれ集合を表現する領域の大きさを持つとして考えてください。

![関数型の部分型関係](/images/ast/img_function-subtyping-piping.jpg)

$S_2: P_2 \rightarrow R_2$ という関数型を図のような $P_2$ という領域の大きさを持つ入力口と $R_2$ という領域の大きさを持つ出力口のある水が流れるパイプとして考えてください。$P_2$ の面積を流れてくる入力をパイプ外にこぼさず、かつ $R_2$ の面積を流れてくる出力をパイプ外にこぼさないように別のパイプ($S_1: P_1 \rightarrow R_1$)で安全に置き換えるとします。

図の(1)では入力口である $P_1$ の面積が元の入力口の $P_2$ よりも小さいため入力となる水がこぼれて危険であり、(3)では逆に出力口である $R_1$ の面積が元の出力口の $R_2$ よりも小さいため出力となる水がこぼれて危険な置換となります。

一方、図の(2)では元の入力口の $P_2$ よりも大きな面積をもつ $P_1$ で入力となる水を受け取り、元の出力口の $R_2$ よりも小さな面積を持つ $R_1$ で出力となる水を吐き出します。これによって上下で繋がっているパイプの外側に水がこぼれることなく安全にパイプの入れ替えができることがわかります。

このように入力と出力の値の範囲の外側となるような危険な入出力をとらない関数であれば元の関数が期待されるような場所で使用しても大丈夫というわけです。

これが関数の型における部分型についての基本的な関係です。現実的には TypeScript の関数型では利便性のために関数の引数については双変(bivariant)となるように設計されています。引数として受け取る関数の型がより特殊化されたものとして受け取れるほうが便利なケースが多いためです。つまり上図の(1)のようなパターンを認めています。

## C# における型と部分型関係の圏

ここで別の言語でも同様のことを考えることができることを示すために C# という言語での型構築子と変性について考えていみます。

C# 言語は TypeScript のコア開発者である Anders Hejlsberg 氏が Microsoft で開発したものですが、TypeScript と同じように部分型関係を持つ型システムの言語です。TypeScript において変性を圏論の関手で説明する記事はほとんど見かけたことがないですが、C# ではいくつかの記事が存在しており、例えば以下の記事が非常に分かりやすいです。

https://tomasp.net/blog/variance-explained.aspx/

C# のプリミティブ型は TypeScript よりも数が多く、特に数値に関する型はデータサイズとして詳細化されています。型システムの特徴としては `void` 型がユニット型に相当し、トップ型は [`object`](https://learn.microsoft.com/ja-jp/dotnet/csharp/language-reference/builtin-types/reference-types#the-object-type) 型となりますが、ボトム型は存在しません。

以下の図は[公式ドキュメント](https://learn.microsoft.com/ja-jp/dotnet/csharp/fundamentals/types/#the-common-type-system)を参考にした型の基本配置です。かなり省略されているようなので注意してください。

```mermaid
graph BT
O["System.Object"]
SV["System.ValueType"]
SE["System.Enum"]
UC["User-defined classes and interface"]
SS["System.String"]
SA["System.Array"]

AE["All enums"]
SI["System.Int32"]
SB["System.Boolean"]
US["User-defined structs"]

subgraph A[Value Types]
direction BT
  AE
  SI
  SB
  US
  SE
  SV
end
subgraph B["Reference types"]
direction BT
O
SV
SE
UC
SS
SA
end

AE --> SE --> SV
US & SI & SB --> SV
SV --> O
SS & SA & UC --> O
```

`System` という名前空間がありますが、それぞれの型にはエイリアスがついており、通常は短いエイリアスの方を利用して型宣言などを行うようです(例えば `System.Object` 型なら `object` 型としてエイリアスが存在する)。

さて、C# には [`IEnumerable<T>`](https://learn.microsoft.com/ja-jp/dotnet/api/system.collections.generic.ienumerable-1?view=net-8.0) というインターフェース型が存在します。この型は公式の[共変性と反変性のドキュメント](https://learn.microsoft.com/ja-jp/dotnet/csharp/programming-guide/concepts/covariance-contravariance/)によると共変とのことです。

```cs
IEnumerable<string> strings = new List<string>();
IEnumerable<object> objects = strings;
```

ということで `IEnumerable<T>` の型構築子は共変関手となり、順序関係(部分型関係)を保持して構造をマッピングします。

![csharpのIEnumerable関手](/images/ast/img_csharp-ienumerable-functor.png)

逆に [`Action<T>`](https://learn.microsoft.com/ja-jp/dotnet/api/system.action-1?view=net-9.0) の型構築子は反変関手となるため、順序関係(部分型関係)を反転して構造をマッピングします。

```cs
static void SetObject(object o) { }
Action<object> actObject = SetObject;
Action<string> actString = actObject;
```

対象(型)の位置はそのままにして図示すると、以下のように射(部分型関係)の向きが反転しているのが分かります。

![csharpのAction関手](/images/ast/img_csharp-aciton-functor.png)

## 型と関数の圏

副作用などを無くした純粋関数と型の世界を作り、様々な理想的な条件を考えることで TypeScript においても Hask のような「型を対象、射を関数とした圏」を考えることができます。

そのような圏は一般に「**カルテシアン閉圏** (CCC: [Cartesian closed category](https://en.wikipedia.org/wiki/Cartesian_closed_category))」あるいは「**デカルト閉圏**」と呼ばれ、関数型プログラミングにおける重要な意味論を構築します。この圏においては型の和(バリアント型)や積(タプル型)、冪(関数型)といった種々の型対象について多くの考察を行うことが可能となり(カリー化や随伴など)、部分型関係とは少々異なる半環(和と積を持つ代数系)の代数が可能となります。

圏論における対象同士の構造的な同じさを表現する概念として同型性 (isomorphism)($\cong$) を導入しましたが、前順序集合を元に構成した圏における双方向の関係を示す同値関係は同形成と一致していました。型と関数の圏での同型性も型同士の構造的な同じさを表現しますが、これによって今まで考えてきた部分型関係に基づく代数とは別の種類の型の代数(type algebra)を行えるようになります。

例えば、型と関数の圏において「冪対象 (exponential object)」とは関数型のことであり、圏の対象の一つとしてモデル化されます。集合論的には写像の集合である配置集合であり、型 $E$ から型 $F$ への関数の集合 $F^E$ ということになります。そして、型の和の冪対象(タプル型を引数にとる関数型)は冪対象と冪対象の直積(関数型のタプル型)が同型となり、型同士のある種の同じさを以下のような恒等式によって語ることができます。

$$
Z^{X+Y} \cong Z^X \times Z^Y
$$

これは学校の数学で習う指数法則とまったく同じであることに気づきます。

$$
\begin{aligned}
a^{b+c} &= a^b \times a^c \\
3^{1+2} &= 3^1 \times 3^2 \\ &= 3 \times 9 = 27 = 3^3 \\
\end{aligned}
$$

このような型の代数について興味がある場合には以下の『Reason Isomorphically!』という論文を参照してみてください。高校数学と同じ代数が型の同型性において繰り広げられているの覗くことができます。

https://www.cs.ox.ac.uk/ralf.hinze/publications/WGP10.pdf

筆者は圏論をそこまで使いこなしていないので正直手が余りますが、そのような圏については Haskell や Scala を中心にして種々の資料がインターネット内外で手に入りますので探してみてください。また、入門の動画としては Bartosz Milewski 氏の以下の動画『A Crash Course in Category Theory』などが分かりやすいです。

https://www.youtube.com/watch?v=JH_Ou17_zyU

日本語で手に入る資料としては以下の書籍などもあります。

https://www.kyoritsu-pub.co.jp/book/b10008105.html

上の書籍は少々取っ付きづらいと思いますが、より親しみやすい入門書としては imonikike さんが執筆した『JavaScript 徹底攻略関数』という電子書籍がおすすめです。この書籍の付録において JavaScript での型と関数の圏について分かりやすく解説しています。

https://booth.pm/ja/items/4435258

この本でもいずれ扱うかもしれません。
